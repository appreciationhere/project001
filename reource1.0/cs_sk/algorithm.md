# C++
rand() 返回一个随机数; 有符号型的的右移是算术右移, 左边补上原符号位, 所以-1 >> 1 == -1;
## 字符串操作

cin:空格或者回车结束；getline(cin,s)；字符串的查找 string.find(s),find(s,开始查找下标)，返回下标位置，否则返回 string::npos ; ios_base::sync_with_stdio(false)可以取消 cin,cout 的缓存读取，增强读取的速度 cin.tie(0); substr('起始位置'， 大小) ;string 可以之间 + 上一个字符串或者字符 erase('pos','pos') ; insert ('pos', 'string')坐标或者是迭代器 移除字符； #include< cstring>; 字符串和空字符相加要写成s  = "  " + s 而不是 s = s + " "; int p = stoi(str);to_string(1111);
## 常用STL库数据结构

### 队列和栈

先 .push()，再用 .front()/.top() ,.pop()，back(); 可以直接 push(P(x,y))(P 为 pair 类型)；

### vector 可变数组 和 deque双端队列

vector< int> a(10,1) 大小为 10 都初始化为 1，可以返回第一个和最后一个元素，和删除最后一个元素和 erase(a.begin() + 1, a.begin() + 3) 前闭后开，pop_back() 移除最后一个元素; insert(a.begin() + 1, 3, 5) 插入入 3 个数都为 5; front(); back() ; data() 返回第一个元素的指针 ; vector< vector< int>> grid(2, vector< int >(5,0)) 申请二维数组; vector 之间相互的赋值是复制一份到另外一个中， = 是判断里面的元素是否都相等；find(v.begin(), v.end(), '元素') 返回的是指针 不是vector的自带函数;  deque可以pop_front()和push_front(); swap(a, b) == a.swap(b); vector<int> v1(v2.begin() + 2, v2.end() - 1);

### set 和 map

set: insert (); set< int>::iterator ite; ite = s.find(1),if( ite == s.end() ) cout<<"not found" 或者 s.count(3) != 0 则找到（查找操作）；.erase(3)删除元素；遍历用 for (set<edge*>: :iterator i = (head->edges).begin(); i != (head->edges).end(); i++) cout<< * i; map:一般和 pair 并用，first 为键，一般都只对键值操作，可以用数组从下标[1] 开始遍历,可以用迭代器 first，second 遍历； map['a'] = 12, map['b'] = 11 修改值; .count(key) 返回数量； set.lower_bound(key) 返回 key 元素下限的指针; map 重载operator＜()操作符;

### list 和 bitset

通用迭代器 next('iterator') ; prev('iterator', 'n'); bitset<1024> b(0), b("1010"), b(12) 前面由 0 替代, 可以下标访问值, 可以用 <<,>>,~,还可以与0x01相与/或, 等运算 .count() 返回1的数量, to_string(), toulong() 返回无符号长整型, toullong()

## c++常用函数

### sort 和 pair

typedef pair< int,int> p(\#include < utility> ) 无需写出类别，就可以用 make_pair(键值，值)来生成 pair 对象一般用作参数的值传递，也可以用 typedef pair< int, const char\* > P, P(x,y)来传递，区别是参数类型; sort(.begin(),.end(),compare)来进行快排，compare()设置排列 a>b return true 是从大到小排，传入 pair 数组默认对 first 进行从小往大排序，对应关系不变，前闭后开(#include< algorithm>)
sqrt()只能对double、float类型; pow也是需要浮点型;

### memset 和 fill 

memset:memset(‘首地址’0/-1，内存大小）< cstring>；fill(''开始地址''，'末尾地址'，‘val’) < algorithm> //因为 memset 是对单个字节操作的，所以如果除了字符型的赋其他初值有意义，其他类型的赋其他初值没有意义

abs() , pow(double x, double y) 开放 1/y 可以用来求方根 < cmath>; move()有值; lower_bound(a.begin(), a.end(), m) a为升序，返回第一个大于等于m的指针；emplace 高效的插入操作, upper_bound(a.begin(), a.end(), m) a为升序，返回第一个大于m的指针； 
```
            upper_bound(jobs.begin(), jobs.begin() + i - 1, jobs[i - 1][0], [&](int st, const vector<int> &job) -> bool {
                return st < job[1];
            })
```
## 常见数据结构

### 递归

1.思考递归最后一步的上一步是什么，从最后往前面推；2.思考 1 的关系得到递推的参数，通过列图查看递推需要几个公式。

### dfs和bfs
bfs一般用于最短路径, 保证不会重复路径和能保证最优解, 广度优先搜索方法的正确性在于：我们一定不会到达同一个位置两次及以上，因为这样必定不是最少的移动次数;
### 优先队列和堆

解决插入，并取出最小的高效结构为优先队列，堆是高效实现的一种(O(logn))；一般用数组表示堆，只需要依次进行从小往大的排序即可，可以用 priority_queue<类型，（存储类型），容器比较方法> p，容器比较方法有 less<类型>，greater< 类型>，默认是 less(pair 先比较第一个元素，相等再比较第二个)，可以自己写结构体定义变量，并重写 less <, greater >, less是大根堆; greater<> 里面可以忽略;
```       
        bool operator < (const job & j2) {
            return endTime < j2.endTime;
        } 
```
例子：汽车加油问题，PTA.cpp::solve3(),整体思路是在汽油为 0 时最远能走到哪，再把走过的加油站放入到优先队列中，油不够走完下一站了就直接取 top 的汽油数同时加油次数++。所以通过每走过一个加油站，判断最外层循环 1 为遍历加油站数目，同时可以将终点看成一个特殊的加油站，遍历结束就输出加油次数，同时在 1 中判断能否走过，能就把当前加油站入队。

### 并查集

用来管理分组情况的数据结构，可以高效的查询元素 a 和元素 b 是否属于同一组，合并元素 a 和元素 v 所在的组;实现：创建一个 par[]父亲数值，和 rank[]高度数值，按标号初始化，利用数组的标号来存储它的父根，如编号 2 是编号 1 的父根，则 par[1] = 2;当 rank 太大时可以单独定义 1，2，3；par 的父根只有 1，2，3 这几种

### 图

构件图的两种方法，一种是二维数组一种是构建 vector 数组；对圈的判断;
图的最短路径问题;
分有负圈和没有负圈两种情况，以及单元两点还是任意两点；有负圈的单元两点用 Bellman-Ford,无负圈单元两点用优先队列(vector 数组存储边)，其他用 Floyd-Warshall 算法；

### other

#### 快速幂
    o(logn)时间求解2^n % MOD;
```
    typedef long long ll;
    ll quick_pow(ll x,ll n,ll m){
        ll res = 1;
        while(n > 0){
            if(n & 1) res = res * x % m;
            x = x * x % m;
            n >>= 1;//相当于n=n/2.详情请参考位移运算符。
        }
        return res;
    } 
```
#### 树状数组
求前 n 项和以及修改单值; 维护的是前缀和，目的是方便求任意区间段的和以及对值进行修改, 空间(o(n)), 时间都是 (o(logn));
**原理**: lowbit表示当前i所管理的数据个数(二进制下第一个1出现的大小, 比如0x07为1, 0xf8为8), 查找[1-i]的前缀和时, 加上当前i的值, 再跳转到上一个前缀的i, 直到i为1; 修改单值同理, 为后缀, i不大于n;
```
    int temp[100] = {0};  //树状数组 
    int main() {
        int L[9] = {0,2,3,4,5,6,7,8,9};
        creat(L,8); 
        for (int i = 1; i < 9; i++)
            cout<<temp[i]<<"  ";
        cout<<'\n';
        for (int i = 1; i < 9; i++)
            cout<<ask(i)<<"  ";
        add(1, 3);
        cout<<'\n';
        for (int i = 1; i < 9; i++)
            cout<<ask(i)<<"  ";
    }
    int lowbit(int m) {
        return m & (-m);
    }
    // 初始化
    void creat(int* L, int n) {   
        for (int i = 1; i <= n; i++) {
            add(i, L[i]);
        }
    }
    // 向第i项添加num
    void add(int n,  int num) {
        //8是数组的大小，num是增加的值，增加第n个数的值
        for (int i = n; i <= 8; i += lowbit(i))
            temp[i] += num;
    }
    // 得到前n项和
    int ask(int n) {  
        int sum = 0;
        for (int i = n; i >= 1; i -= lowbit(i))
            sum += temp[i];
        return sum;
    }
```
#### 差分数组
    应对频繁的区间修改操作，例如在区间 1-4 的值都减一，代价是要构建一个差分数组，d[i] = d[i] -d[i - 1] ,d[0] = 0; 当给 1 - 4 都加 3 时只需要对 d[1] + 3, d[5] - 3;

#### 单调队列
    能够添加和删除并得到当前的最大/小值, 且是滑动窗口; 
``` 
    for (int i = 0; i < arr.size(); ++i) {
            while (!buf.empty() && arr[i] < arr[buf.back()])
                buf.pop_back();
            left[i] = buf.empty()? i + 1 : i - buf.back();
            buf.push_back(i);
    }
```
### 线段树
能够进行区间的'和'(只要[l,mid][mid+1,r]满足结合律), 修改单值或者区间'相加'(只要[l,mid][mid+1,r]满足结合律);
```
    /*题目描述
    如题，已知一个数列，你需要进行下面两种操作：
    1.将某区间每一个数加上x
    2.求出某区间每一个数的和
    输入格式
    第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。
    第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。
    接下来M行每行包含3或4个整数，表示一个操作，具体如下：
    操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k
    操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和
    输出格式
    输出包含若干行整数，即为所有操作2的结果。
    */
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e5 + 5;
    typedef long long ll;
    ll tree[MAXN << 2], mark[MAXN << 2], n, m, A[MAXN];
    void push_down(int p, int len)
    {
        if (len <= 1) return;
        tree[2 * p] += mark[p] * (len - len / 2);
        mark[2 * p] += mark[p];
        tree[2 * p + 1] += mark[p] * (len / 2);
        mark[2 * p + 1] += mark[p];
        mark[p] = 0;
    }
    void build(int p = 1, int cl = 1, int cr = n)
    {
        if (cl == cr) {
            tree[p] = A[cl];
            return;
        }
        int mid = (cl + cr) / 2;
        build(2 * p, cl, mid);
        build(2 * p + 1, mid + 1, cr);
        tree[p] = tree[2 * p] + tree[2 * p + 1];
    }
    ll query(int l, int r, int p = 1, int cl = 1, int cr = n)
    {
        if (cl >= l && cr <= r) return tree[p];
        push_down(p, cr - cl + 1);
        ll mid = (cl + cr) >> 1, ans = 0;
        if (mid >= l) ans += query(l, r, 2 * p, cl, mid);
        if (mid < r) ans += query(l, r, 2 * p + 1, mid + 1, cr);
        return ans;
    }
    void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n)
    {
        if (cl >= l && cr <= r) {
            tree[p] += d * (cr - cl + 1), mark[p] += d;
            return;
        }
        push_down(p, cr - cl + 1);
        int mid = (cl + cr) >> 1;
        if (mid >= l) update(l, r, d, 2 * p, cl, mid);
        if (mid < r) update(l, r, d, 2 * p + 1, mid + 1, cr);
        tree[p] = tree[2 * p] + tree[2 * p + 1];
    }
    int main()
    {
        ios::sync_with_stdio(false);
        n = 100;
        for (int i = 1; i <= 100; ++i)
            A[i] = i;
        build(1, 1, n);
        update(10,15,1);
        cout<<query(10, 15);
        return 0;
    }
```

## 优化算法
### 二分

#### dp二分
1. 求解最长递增子序列
/*  
    例题:给定一个长度为 N的整数序列, 现在你有一次机会, 将其 中连续的 K 个数修改成任意一个相同值。
	请你计算如何修改可以使修改后的数 列的最长不下降子序列最长, 请输出这个最长的长度。
    首先要明白什么是不下降子序列, 可以发现, 我们的最长不下降子序列由3部分构成, 一部分是修改的区间前面的不下降子序列,
    和修改的区间, 以及 修改区间后面的不下降子序列, 因为中间是固定的, 如果我们可以通过遍历一个区间的值, 来得到另外一个区间的
    最大值, 那么我们就可以得到整个的 最长不下降子序列; tail[i]是预处理得到以i为开头, n为结尾的最长不下降子序列, dp为辅助计算
    最长不下降子序列的数组, 我们通过二分来得到当前为开头或者结尾的最长不下降子序列, pre[i]是以1为开头, i为结尾的 最长不下降子序列;
*/

```
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
ull nums[100002];
ll pre[100002];
ll tail[100002];
ull dp[2][1000002];
ull n, m ,ans = 0;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	memset(dp[0], -1, sizeof(dp[0]));
	cin>>n>>m;
	for (ull i = 1; i <= n; ++i)
		cin>>nums[i];
	for (ll i = n; i >= 1; --i) {
		ll buf = upper_bound(dp[1] + 1, dp[1] + (n - i + 2), nums[i], [] (const ll &a, const ll &b) {
					return a > b;
				}) - dp[1];
		dp[1][buf] = nums[i];
		tail[i] = buf;
	}
	ll cnt = 1;
	for (ull i = m + 1; i <= n; ++i) {
		ll buf = upper_bound(dp[0] + 1, dp[0] + cnt, nums[i - m]) - dp[0];
		ans = max((ull)(tail[i] + upper_bound(dp[0] + 1, dp[0] + cnt, nums[i]) - dp[0]), ans);
		if (buf == cnt)
			++cnt;
		dp[0][buf] = nums[i - m];
	}
	cout<<(ans + m - 1);
	return 0;
}
```
### lca

#### 倍增lca
在树里面寻找最近公共祖先; 
1. build函数预处理得到dep深度数组;
```
void build(int u, int fa, ll d) {
    dep[u] = dep[fa] + 1, dist[u] = d, f[u][0] = fa;
    for (int i = 1; (1 << i) <= dep[u]; ++i) f[u][i] = f[f[u][i - 1]][i - 1];
    for (auto &p : g[u]) {
        if (p.first == fa) continue;
        build(p.first, u, d + p.second);
    }
}
```
2. lca(a, b)得到a,b的最近公共祖先
```
int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);
    for (int i = 20; i >= 0; i --) {
        if (dep[f[a][i]] >= dep[b]) a = f[a][i];
        if (a == b) return a;
    }
    for (int i = 20; i >= 0; i --) {
        if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];
    }
    return f[a][0];
}
```

### 动态规划

1. 最优解来自于出现过的最优解, 可以写出递推关系式;
2. 自顶向下: 递归; 从下往上: for 循环

### 动态规划 + dfs

通过**dfs的参数**选择来记录dp, 再次达到时直接取dp的值

#### 数位DP
```
    // 返回从第 i 位开始的 <= n 的个数
    private int f(int i, boolean isLimit) {
        // 结束条件
        if (i == s.length) return 1;
        int up = isLimit ? s[i] - '0' : 9;
        int res = 0;
        for (int j = 0; j <= up; ++j) {
            res += f(i + 1, isLimit && j == up);
        }
        return res;
    }
```

##### 1012.至少有 1 位重复的数字
##### 902.最大为 N 的数字组合
    
### DFS

1. 已经做出的选择;
2. 当前可以做的选择;
3. 结束的条件;
4. 优化剪枝
## 数论算法
### 素数筛选
素数筛选可以通过埃拉托斯特尼筛法来实现，该算法的步骤如下：
1. 从2开始，将所有小于等于n的自然数放入一个数组中；
2. 从2开始，将其倍数从数组中删除；
3. 重复步骤2，直到所有小于等于n的自然数都被删除；
4. 剩下的数即为素数。
### 欧拉函数
欧拉函数即f(n), n的前n - 1个数和n的互质数的个数; 素数的f(n)=n - 1, 如果n1, n2为素数, f(n1 * n2)=f(n1)*f(n2)
f(n)=n*(1-p1)*(1-p2)*(1-p3)*...(1-pn) (pn为n的质因数)
欧拉函数可以通过欧拉筛法来实现，该算法的步骤如下：
1. 从2开始，将所有小于等于n的自然数放入一个数组中；
2. 从2开始，将其倍数从数组中删除；
3. 将剩下的数的欧拉函数值计算出来；
4. 重复步骤2，直到所有小于等于n的自然数都被删除；
5. 将所有计算出来的欧拉函数值相加，即为n的欧拉函数值。
### 最小公倍数
最小公倍数的算法是：首先求出两个数的最大公约数，然后将两个数相乘，再除以最大公约数，得到的结果就是最小公倍数。
### 最大公约数
最大公约数算法是：首先求出两个数的较大值和较小值，然后用较大值除以较小值，如果余数为0，则较小值就是最大公约数；如果余数不为0，则将较小值作为除数，将余数作为被除数，重复上述步骤，直到余数为0，此时被除数就是最大公约数。
### 分解质因数
```
for (int i = 0; i <= n / i; ++i) {
    int x = nums[i];
    for (int d = 2; d * d <= x ; ++d) { // 分解质因数
        if (x % d == 0) {
            f(d, i);
            for (x /= d; x % d == 0; x /= d);
        }
    }
    if (x > 1) f(x, i);
}
```
### 莫队区间查询算法

### kmp && manacher











## 左程云算法班

### 基础班

mid = L + ( R - L) >>1; master 计算复杂度：T(N) = a T(N/b) +o (N ^d) 1.logba < d 为 o(N^d) 2. logba > d 为 o(N^logba) 3.相等 为 o(N^d \* log bN) 归并排序的拓展：小和问题和逆序对问题，小和：在一个数组中每一个数比当前数小的累加起来，叫做这个数组的小和，逆序对：参考线性代数第一章; 荷兰国旗：排序成 3 对，左为小于，中为相等，右为大于

系统的提供的堆只有添加和弹出才具有高效，其他功能需要自己写；比较器：返回负数，第一个在前面，返回 0，无所谓 ，比较器可以用于排序堆或者快排等；基数排序：先计算最大的数有几位，再准备 1 个大小为 10 的数组 a 存储前缀和，a[i]代表小于 i 的数有几个，再从后往前遍历，根据 a[i]的值填到辅组数组中，a[i] -1;排序稳定性 ；

综合排序：改进算法，当样本量小于 60 时使用插入排序，大于 60 时使用快排；系统的 sort 排序当用默认排序规则是快排，用自己定义的方法排序是归并； hash 表 ，按值传递是拷贝，其他是引用 , 增删改查都是 o(1) ，无序组织 ； tree 表(有序表) ，不是基础类型，必须提供比较器，内部引用传递，o(logN) ; 快指针和慢指针，单链表判断回文数，笔试用栈实现 空间 o(N)，面试用快慢指针 o(1) ；链表的的荷兰国旗问题，o(N)的做法是开辟一个 N 的数组，然后 partition，o(1)是用 6 格指针分别指向小于，等于，大于区域，最后串联起来 ；复制一个特殊的单链表，1.用 hashmap 实现，2.用 random 的性质在每一个链表的下面复制一个单链表； 找到两个可能有环的可能相交的单链表的相交的节点，没有返回 null，1.用 set 判断是否有环 2.用公式判断是否有环

先序，中序，后序遍历的非递归形式，先序是先将头节点压入栈中，再 pop，再把左右节点压入，直到栈为空，中序遍历是先把头节点和所有左孩子都压入栈中，再 pop，同时把右孩子压入栈中，把刚刚压入的右孩子当作头节点，直到栈为空，后序遍历可以在先序的基础上再添加一个栈，栈中顺序就是后序遍历；宽度遍历用队列，计算二叉树的最大宽度 1.用 hashmap 记录每一个节点的深度 2.用 两个指针一个指向 level 的末尾，一个指向队列的最后一个，当最后一个等于一个 level 的末尾时就重新统计

判断是否是搜索二叉树，中序遍历是升序的就是搜索二叉树；判断是否为完全二叉树用宽度优先遍历判断；判断是否为平衡二叉树用递归得到右边和左边是否是平衡二叉树以及高度；树形 DP：左数要信息，右数要信息可以解题的套路；递归判断是否是满二叉树；找出两个节点的最近父节点 ; 将二叉树序列号和反序列：什么方式序列化就什么方式反序列化，例如先序序列化，就按照先序的顺序反序列化

用自己喜欢的图结构实现每一种图算法，之后题目给定的特定的图再通过自己喜欢的图表达修改，入度是有多少点指向这个点，出度是自己有多少边，next 是属于该节点的边可以直接连上的节点；图有点集和边集，边有 weight to from ；set 保证没有重复的边输出；拓扑排序：先找入度为 0 的点，把这个点输出，把这个点的影响都擦掉，继续找入度为 0 的点，具体先遍历每一个点，把入度放到一个 map 里面去，顺便找出入度为 0 的点；最小生成树(无向图) ，边的累加和最小，且联通，算法 1，把边排序，再加上，看是否形成环，形成环就不加，否则就加上，集合查询和集合的合并可以实现判断环(并查集)，算法 2，任意选一个节点，将它的边放入优先队列中，然后弹出最小边，判断 set 中是否有 to 节点，再把边放入 result 中，再把这条边的 to 节点的边放入优先队列中循环，直到队列为空； Dijk 算法(累加和为负数的环) 求最小路径：

前缀树：对加入的字符串进行处理，使能够判断是否加入过该字符串和是否包含某字符串的片段 ,一般把字符放到边上，点上存储的是经过该路的次数和以该路为终点的字符串数，创建删除和查询 ; 贪心算法：局部最优 -?-> 整体最优 ;切金条问题，哈夫曼树； 查找一组数的中位数， 用一个大根堆和一个小根堆，每放入一个数和大根堆的跟顶比较，大于放入小根堆，否则放入大根堆，当两堆大小相差为 2 时弹出大的顶部到另一个中，则两堆的顶部就是中位数；n 皇后问题 :可以利用位运算加速

dijk 算法加速，用小根堆，需要自己写一个如果不存在则新加入，存在则判断大小，小的化就加入，大的化就忽略； 打印字符串的子字符串； 字符串的全排列

### 基础提升班

hash 函数性质：虽然 out 出来的是有限的数，但足够多 ；可以将传进来的数进行随机区域的均分；应用：1. 比如有 40 亿个数，找出出现次数最多的数，可以先把每个值传进 hash 函数，出来的值 % 100，然后对 100 个小文件进行 hashmap 来找出最大值； hash 表的应用之删除和随机返回一个数 o(1)，建立两个哈希表，各自存值和 index，删除把最后一个填充到删除的位置中 size--，随机返回调用系统的随机函数返回 0-size - 1； 布隆过滤器：通过位运算，把加入的 int 类型的值通过对不同的 hash 函数处理，把不同 hash 函数出来的每一个数的该位都描黑，查找的时候调用每一个 hash 函数，如果都描黑则在黑名单中；失误率是有的，当分配的空间越少失误率越大

并查集：3 个 map，一个 map 用 val 找到 element，一个记录父节点，最后一个记录顶端节点的大小；每一次合并要把大小小的往大小大的上面链接，并移除最后一个图中的小的节点；每一次 findHead 都需要把路上的每一个节点的父节点直接指向顶部节点;
kmp: 先求s2的next数组, next数组的定义为前缀和后缀相等的长度, 比如aabaa next数组为[-1, 0, 1, 0, 1], aaacba 为[-1, 0, 1, 2, 0, 0, 1], next数组一定是-1开头的, 因为最后一个没有意义, 所以舍弃了, 总体长度为s.size(), next数组在比较中可以让遍历s2的s2[j]与s1[i]不相等时, 不用将j置为0, 应该j = next[j], 再继续比较, 这样做来自两个证明, 第一个是j = nenxt[j]后, s2的[0 - j]与s1数组i之前的字符串相等, 第二个是这个j之前的字符串都能在i之前找到, 但是j之后的都不能, j是最大的那个;
manacher: 求一个字符串的最长回文字串算法; 因为需要考虑两种回文字串, 如abba, aba, 我们通过填充字符来达到只按一种情况计算, 如abba填充后变成,#a#b#b#a#, 这样我们就只需要考虑一种情况; 有一个R和C, 表示当前右侧最大的以C为中心的字串, 比如acacab, C为2时R为4, C为3时R为5, 如果当前的i在R外面, 则暴力搜索更新, 并更新C和R, 如果i在R里面, a[L ... i'... C ... i ... R]b, 因为C的[L,R]内, 左右对称, 所以i的回文字串与i'有关系, 当i'的R小于R - i时, i的R就等于i'的R, 当i'大于R - i, 因为以C为中点当前已经是最大回文字符串, 所以a != b, 所以i为R - i, 当i'为R - i时, i至少为i'继续往下搜索;
单调栈: 解决在滑动窗口的情况下得到当前的最大值或者最小值;

树形 dp，第一步：以某个节点 x 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 x 的左右子树和 x 整棵树的角度来考虑可能性的。第二步：根据第一步的可能性分析，列出所有需要的信息。第三步：合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构。第四步：设计递归函数，以处理以 x 为头节点的情况下的答案，默认直接得到左树和右树的所有信息，以及把可能性做整合;
Morris遍历: 1.cur当前节点没有左孩子, 则cur向右移动, cur=cur.right; 2.有左孩子, 则找到左孩子的最右节点mostRight, a.mostRight的右指针为空, 则将其指向cur, 并且cur向左移动, b.如果为cur, 则指向null, cur向右移动; 3.cur为空则停止遍历; 其正确性在于, 我们每一个有左孩子的节点都会回到两次, 而递归的遍历每一个节点都会回到3次, 当我们找mostRight的右指针时遍历到了当前的cur, 说明我们刚刚从这个mostRight遍历过来, cur的左子树以及遍历完, 所以我们应该将cur右移遍历右边, 我们可以利用其第几次回到和该节点以及是否有左节点就可以进行先序中序和后序的遍历, 先序根据Morris的遍历顺序, 我们只需要第一次遇到这个节点的时候打印它; 中序需要在第二次遇到时打印, 另外如果没有左节点的话应该直接打印; 后序需要把每一个遍历到节点及其右节点都逆序打印, 再逆序打印跟节点节点及其右节点;
当40个亿的数的范围是0-2^32 - 1时, 我们如何在只有3kb的内存下找到一个不存在的数: 我们申请512个int类型的空间arr[512], 对每个数都除以(2^32/512)得到的i来进行++arr[i], 最后只要找到总数小于(2^32/512)就一定缺少数, 再对该一段区间的数(i*2^32/512) 再进行细分为512个单位, 依次反复就能找到答案;如果两个变量还可以进行二分处理;

当输入的数据是海量文件时, 我们可以通过hash函数进行分流, 把它写到很多个小文件里面, 再在小文件上面用hash表统计; 如何再海量搜索词频中找到top100: 我们将很多个小文件做成大根堆, 再做一个总的大根堆, 将每个文件的堆顶放入总堆, 再弹出总堆的堆顶, 并将弹出数据的堆的堆顶再放入总堆, 直到总堆弹出满足条件的数量; 如何使用少量空间找到40个亿数的中位数: 申请k个4字节的空间arr, 将40亿均分为k个, 如arr[0]表示0-40亿/k的范围, 遍历一遍40亿个数, 找到第20亿个数的范围, 再进行遍历得到这个范围内的中位数就是答案; 
如何判断一个一个数是否是2的冥, 判断是否是4的幂; 只通过位运算来实现两个数的相加相减相乘和相除;

打表方: 输入一个整数, 要求返回一个整数, 就能使用该方法; 先写一个普通的版本, 把前100或更多求出来后, 再去找规律, 最后利用这个规律来优化代码;
二进制01法, 给你一个随机返回0-6的, 要求利用产生一个随机返回0-10的函数 先将0-6均分, 比如返回0-2返回1, 返回3-5就返回0, 否则重新来, 这样就得到等概率返回0-1的函数, 再将最大的10分成4位, 低的3位都正常调用01随机函数得到, 最高位掉完后如果大于10, 则都重新掉一遍; 给你一个p概率返回1,(1-p)概率返回0, 求生成一个随机等概率返回0或者1的函数 因为p(1-p)=(1-p)p 再按照刚刚的方法做成01函数;
